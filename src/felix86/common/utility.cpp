#include <array>
#include <cstring>
#include <fstream>
#include <sys/ioctl.h>
#include "Zydis/Decoder.h"
#include "Zydis/Disassembler.h"
#include "felix86/common/elf.hpp"
#include "felix86/common/state.hpp"
#include "felix86/common/utility.hpp"
#include "felix86/hle/cpuid.hpp"
#include "felix86/v2/recompiler.hpp"
#include "fmt/format.h"

#ifdef __riscv
#include <sys/cachectl.h>
#endif

struct fxsave_st {
    u8 st[10];
    u8 reserved[6];
};

struct fxsave_data {
    u16 fcw;
    u16 fsw;
    u8 ftw;
    u8 reserved;
    u16 fop;
    u64 fip;
    u64 fdp;
    u32 mxcsr;
    u32 mxcsr_mask;
    fxsave_st st[8];
    XmmReg xmms[16];
    u64 reserved_final[6];
    u64 available[6];
};
static_assert(sizeof(fxsave_data) == 512);

/* Libdivide LICENSE


  Copyright (C) 2010 - 2019 ridiculous_fish, <libdivide@ridiculousfish.com>
  Copyright (C) 2016 - 2019 Kim Walisch, <kim.walisch@gmail.com>

  Boost Software License - Version 1.0 - August 17th, 2003

  Permission is hereby granted, free of charge, to any person or organization
  obtaining a copy of the software and accompanying documentation covered by
  this license (the "Software") to use, reproduce, display, distribute,
  execute, and transmit the Software, and to prepare derivative works of the
  Software, and to permit third-parties to whom the Software is furnished to
  do so, all subject to the following:

  The copyright notices in the Software and this entire statement, including
  the above license grant, this restriction and the following disclaimer,
  must be included in all copies of the Software, in whole or in part, and
  all derivative works of the Software, unless such copies or derivative
  works are solely in the form of machine-executable object code generated by
  a source language processor.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

*/
// libdivide_128_div_64_to_64: divides a 128-bit uint {numhi, numlo} by a 64-bit uint {den}. The
// result must fit in 64 bits. Returns the quotient directly and the remainder in *r
static inline uint64_t libdivide_128_div_64_to_64(uint64_t numhi, uint64_t numlo, uint64_t den, uint64_t* r) {
    // N.B. resist the temptation to use __uint128_t here.
    // In LLVM compiler-rt, it performs a 128/128 -> 128 division which is many times slower than
    // necessary. In gcc it's better but still slower than the divlu implementation, perhaps because
    // it's not LIBDIVIDE_INLINEd.
    // We work in base 2**32.
    // A uint32 holds a single digit. A uint64 holds two digits.
    // Our numerator is conceptually [num3, num2, num1, num0].
    // Our denominator is [den1, den0].
    const uint64_t b = ((uint64_t)1 << 32);

    // The high and low digits of our computed quotient.
    uint32_t q1;
    uint32_t q0;

    // The normalization shift factor.
    int shift;

    // The high and low digits of our denominator (after normalizing).
    // Also the low 2 digits of our numerator (after normalizing).
    uint32_t den1;
    uint32_t den0;
    uint32_t num1;
    uint32_t num0;

    // A partial remainder.
    uint64_t rem;

    // The estimated quotient, and its corresponding remainder (unrelated to true remainder).
    uint64_t qhat;
    uint64_t rhat;

    // Variables used to correct the estimated quotient.
    uint64_t c1;
    uint64_t c2;

    // Check for overflow and divide by 0.
    if (numhi >= den) {
        if (r)
            *r = ~0ull;
        return ~0ull;
    }

    // Determine the normalization factor. We multiply den by this, so that its leading digit is at
    // least half b. In binary this means just shifting left by the number of leading zeros, so that
    // there's a 1 in the MSB.
    // We also shift numer by the same amount. This cannot overflow because numhi < den.
    // The expression (-shift & 63) is the same as (64 - shift), except it avoids the UB of shifting
    // by 64. The funny bitwise 'and' ensures that numlo does not get shifted into numhi if shift is
    // 0. clang 11 has an x86 codegen bug here: see LLVM bug 50118. The sequence below avoids it.
    shift = __builtin_clzll(den);
    den <<= shift;
    numhi <<= shift;
    numhi |= (numlo >> (-shift & 63)) & (-(int64_t)shift >> 63);
    numlo <<= shift;

    // Extract the low digits of the numerator and both digits of the denominator.
    num1 = (uint32_t)(numlo >> 32);
    num0 = (uint32_t)(numlo & 0xFFFFFFFFu);
    den1 = (uint32_t)(den >> 32);
    den0 = (uint32_t)(den & 0xFFFFFFFFu);

    // We wish to compute q1 = [n3 n2 n1] / [d1 d0].
    // Estimate q1 as [n3 n2] / [d1], and then correct it.
    // Note while qhat may be 2 digits, q1 is always 1 digit.
    qhat = numhi / den1;
    rhat = numhi % den1;
    c1 = qhat * den0;
    c2 = rhat * b + num1;
    if (c1 > c2)
        qhat -= (c1 - c2 > den) ? 2 : 1;
    q1 = (uint32_t)qhat;

    // Compute the true (partial) remainder.
    rem = numhi * b + num1 - q1 * den;

    // We wish to compute q0 = [rem1 rem0 n0] / [d1 d0].
    // Estimate q0 as [rem1 rem0] / [d1] and correct it.
    qhat = rem / den1;
    rhat = rem % den1;
    c1 = qhat * den0;
    c2 = rhat * b + num0;
    if (c1 > c2)
        qhat -= (c1 - c2 > den) ? 2 : 1;
    q0 = (uint32_t)qhat;

    // Return remainder if requested.
    if (r)
        *r = (rem * b + num0 - q0 * den) >> shift;
    return ((uint64_t)q1 << 32) | q0;
}

void felix86_div128(ThreadState* state, u64 divisor) {
    // TODO: make this use the above function too, see __divti4
    ASSERT(divisor != 0);
    __int128_t dividend = ((__int128_t)state->gprs[X86_REF_RDX - X86_REF_RAX] << 64) | state->gprs[X86_REF_RAX - X86_REF_RAX];
    u64 quotient = dividend / (i64)divisor;
    u64 remainder = dividend % (i64)divisor;
    state->gprs[X86_REF_RAX - X86_REF_RAX] = quotient;
    state->gprs[X86_REF_RDX - X86_REF_RAX] = remainder;
}

void felix86_divu128(ThreadState* state, u64 divisor) {
    ASSERT(divisor != 0);
    u64 remainder;
    u64 quotient = libdivide_128_div_64_to_64(state->gprs[X86_REF_RDX - X86_REF_RAX], state->gprs[X86_REF_RAX - X86_REF_RAX], divisor, &remainder);
    state->gprs[X86_REF_RAX - X86_REF_RAX] = quotient;
    state->gprs[X86_REF_RDX - X86_REF_RAX] = remainder;
}

u64 sext(u64 value, u8 size) {
    switch (size) {
    case X86_SIZE_BYTE:
        return (i64)(i8)value;
    case X86_SIZE_WORD:
        return (i64)(i16)value;
    case X86_SIZE_DWORD:
        return (i64)(i32)value;
    case X86_SIZE_QWORD:
        return value;
    default:
        UNREACHABLE();
        return 0;
    }
}

u64 sext_if_64(u64 value, u8 size_e) {
    switch (size_e) {
    case X86_SIZE_BYTE:
    case X86_SIZE_WORD:
    case X86_SIZE_DWORD:
        return value;
    case X86_SIZE_QWORD:
        return (i64)(i32)value;
    default:
        ERROR("Invalid immediate size");
        return 0;
    }
}

// Flush icache for current core
void flush_icache() {
#if defined(__riscv)
    asm volatile("fence.i");
#endif
}

// Flush icache globally for all cores
// Quoting kernel documentation:
// If a thread modifies an instruction that another thread may attempt to execute, the other thread must still emit an icache
// flushing instruction before attempting to execute the potentially modified instruction. This must be performed by the user-space program.
//
// For this reason, while we use fence.i when a thread changes its own code to avoid a syscall, when a thread changes a different
// threads code we need to use the syscall instead
// Since each thread has its own code cache this function is currently only used when we invalidate blocks globally
// NOTE: the range is actually unused and only in the syscall for forwards compatibility, so we use it correctly regardless
void flush_icache_global(u64 start, u64 end) {
#if defined(__riscv)
    __riscv_flush_icache((void*)start, (void*)end, 0);
#endif
}

__attribute__((visibility("default"))) int guest_breakpoint_abs(u64 address) {
    g_breakpoints[address] = {};
    return g_breakpoints.size();
}

__attribute__((visibility("default"))) void disassemble(u64 host_address) {
    ZydisDecoder decoder;
    ZydisMachineMode mode = g_mode32 ? ZYDIS_MACHINE_MODE_LONG_COMPAT_32 : ZYDIS_MACHINE_MODE_LONG_64;
    ZydisStackWidth stack_width = g_mode32 ? ZYDIS_STACK_WIDTH_32 : ZYDIS_STACK_WIDTH_64;
    ZydisDecoderInit(&decoder, mode, stack_width);

    u64 cur = host_address;
    while (true) {
        ZydisDecodedInstruction instruction;
        ZydisDecodedOperand operands[10];
        ZyanStatus status = ZydisDecoderDecodeFull(&decoder, (void*)cur, 15, &instruction, operands);
        if (!ZYAN_SUCCESS(status)) {
            printf("Failed to decode instruction at %016lx\n", cur);
            break;
        }

        ZydisMnemonic mnemonic = instruction.mnemonic;
        bool is_jump = instruction.meta.branch_type != ZYDIS_BRANCH_TYPE_NONE;
        bool is_ret = mnemonic == ZYDIS_MNEMONIC_RET || mnemonic == ZYDIS_MNEMONIC_IRETD || mnemonic == ZYDIS_MNEMONIC_IRETQ;
        bool is_call = mnemonic == ZYDIS_MNEMONIC_CALL;
        bool is_illegal = mnemonic == ZYDIS_MNEMONIC_UD2;
        bool is_hlt = mnemonic == ZYDIS_MNEMONIC_HLT;
        bool stop = is_jump || is_ret || is_call || is_illegal || is_hlt;

        ZydisDisassembledInstruction instr;
        ZydisDisassembleIntel(mode, cur, (void*)cur, 15, &instr);

        printf("%lx: %s\n", cur, instr.text);

        if (stop) {
            break;
        } else {
            cur += instruction.length;
        }
    }
}

int clear_breakpoints() {
    int count = g_breakpoints.size();
    g_breakpoints.clear();
    return count;
}

void felix86_iret(struct ThreadState* state) {
    int size = g_mode32 ? 4 : 8;
    u64 rsp = state->gprs[X86_REF_RSP];
    u8* rsp_ptr = (u8*)rsp;
    u64 rip = 0, rflags = 0, cs = 0, ss = 0, new_rsp = 0;
    memcpy(&rip, rsp_ptr, size);
    memcpy(&cs, rsp_ptr + (size * 1), size);
    memcpy(&rflags, rsp_ptr + (size * 2), size);

    if (!g_mode32) {
        memcpy(&new_rsp, rsp_ptr + (size * 3), size);
        memcpy(&ss, rsp_ptr + (size * 4), size);
        state->SetGpr(X86_REF_RSP, new_rsp);
        // TODO: what are we supposed to do with ss?
    }

    u64 mask = 0x3F7BD7;
    rflags &= mask;
    // TODO: actually set rflags

    state->SetRip(rip);

    if (g_mode32) {
        felix86_set_segment(state, cs, ZYDIS_REGISTER_CS);
        state->SetGpr(X86_REF_RSP, rsp + 3 * 4); // 3 values popped
    }
}

struct fenv_data_16 {
    u16 cw;
    u16 sw;
    u16 tw;
    u16 fip;
    u16 fcs;
    u16 fdp;
    u16 fds;
};

static_assert(sizeof(fenv_data_16) == 14);

struct fenv_data_32 {
    u16 cw = 0;
    alignas(u32) u16 sw = 0;
    alignas(u32) u16 tw = 0;
    u32 fip = 0;
    u32 unused = 0;
    u32 fdp = 0;
    u32 fds = 0;
};

static_assert(sizeof(fenv_data_32) == 28);

struct fsave_data_16 {
    fenv_data_16 env;
    Float80 st[8];
};

static_assert(sizeof(fsave_data_16) == 94);

struct fsave_data_32 {
    fenv_data_32 env;
    Float80 st[8];
};

static_assert(sizeof(fsave_data_32) == 108);

void felix86_fsave_16(struct ThreadState* state, u64 address) {
    fsave_data_16* data = (fsave_data_16*)address;
    for (int i = 0; i < 8; i++) {
        Float80 f80 = f64_to_80(state->fp[i]);
        memcpy(&data->st[i], &f80, sizeof(Float80));
    }

    data->env.cw = state->fpu_cw;
    data->env.tw = state->fpu_tw;
    data->env.sw = state->fpu_top << 11;
}

void felix86_fsave_32(struct ThreadState* state, u64 address) {
    fsave_data_32* data = (fsave_data_32*)address;
    for (int i = 0; i < 8; i++) {
        Float80 f80 = f64_to_80(state->fp[i]);
        memcpy(&data->st[i], &f80, sizeof(Float80));
    }

    data->env.cw = state->fpu_cw;
    data->env.tw = state->fpu_tw;
    data->env.sw = state->fpu_top << 11;
}

void felix86_frstor_16(struct ThreadState* state, u64 address) {
    fsave_data_16* data = (fsave_data_16*)address;

    state->fpu_top = (data->env.sw >> 11) & 0b111;
    state->fpu_cw = data->env.cw;
    state->fpu_tw = data->env.tw;
    state->fpu_sw = data->env.sw;

    for (int i = 0; i < 8; i++) {
        double f64 = f80_to_64(&data->st[i]);
        memcpy(&state->fp[i], &f64, sizeof(double));
    }
}

void felix86_frstor_32(struct ThreadState* state, u64 address) {
    fsave_data_32* data = (fsave_data_32*)address;

    state->fpu_top = (data->env.sw >> 11) & 0b111;
    state->fpu_cw = data->env.cw;
    state->fpu_tw = data->env.tw;
    state->fpu_sw = data->env.sw;

    for (int i = 0; i < 8; i++) {
        double f64 = f80_to_64(&data->st[i]);
        memcpy(&state->fp[i], &f64, sizeof(double));
    }
}

void felix86_fxsave(struct ThreadState* state, u64 address, bool fxsave64) {
    fxsave_data* data = (fxsave_data*)address;

    for (int i = 0; i < 16; i++) {
        data->xmms[i] = state->xmm[i];
    }

    for (int i = 0; i < 8; i++) {
        Float80 f80 = f64_to_80(state->fp[i]);
        memcpy(&data->st[i].st[0], &f80, sizeof(Float80));
    }

    data->fcw = state->fpu_cw;
    data->ftw = state->fpu_tw;
    data->fsw = state->fpu_top << 11;
    data->mxcsr = state->mxcsr;
}

void felix86_fxrstor(struct ThreadState* state, u64 address, bool fxrstor64) {
    fxsave_data* data = (fxsave_data*)address;

    for (int i = 0; i < 16; i++) {
        state->xmm[i] = data->xmms[i];
    }

    state->fpu_cw = data->fcw;
    state->fpu_tw = data->ftw;
    state->fpu_sw = data->fsw;
    state->fpu_top = (data->fsw >> 11) & 7;

    for (int i = 0; i < 8; i++) {
        double f64 = f80_to_64((Float80*)&data->st[i].st[0]);
        memcpy(&state->fp[i], &f64, sizeof(double));
    }

    state->mxcsr = data->mxcsr;
    state->rmode = rounding_mode((x86RoundingMode)((state->mxcsr >> 13) & 3));
}

void felix86_pmaddwd(i16* dst, i16* src) {
    ASSERT(((u64)dst & 1) == 0);
    ASSERT(((u64)src & 1) == 0);
    i32 temp[4];
    i32 result[4];

    temp[0] = dst[0] * src[0];
    temp[1] = dst[2] * src[2];
    temp[2] = dst[4] * src[4];
    temp[3] = dst[6] * src[6];

    result[0] = dst[1] * src[1];
    result[1] = dst[3] * src[3];
    result[2] = dst[5] * src[5];
    result[3] = dst[7] * src[7];

    u32* dst32 = (u32*)dst;
    dst32[0] = temp[0] + result[0];
    dst32[1] = temp[1] + result[1];
    dst32[2] = temp[2] + result[2];
    dst32[3] = temp[3] + result[3];
}

void felix86_psadbw(u8* dst, u8* src) {
    u64 result1 = 0;
    u64 result2 = 0;

    for (int i = 0; i < 8; i++) {
        result1 += abs(dst[i] - src[i]);
        result2 += abs(dst[i + 8] - src[i + 8]);
    }

    u64* dst64 = (u64*)dst;
    dst64[0] = (u16)result1;
    dst64[1] = (u16)result2;
}

void dump_states() {
    auto lock = g_process_globals.states_lock.lock();
    auto& states = g_process_globals.states;
    int i = 0;
    for (auto& state : states) {
        dprintf(g_output_fd, ANSI_COLOR_RED "State %d (%ld):" ANSI_COLOR_RESET "\n", i, state->tid);

        if (g_config.calltrace) {
            auto it = state->recompiler->getCalltrace().rbegin();
            while (it != state->recompiler->getCalltrace().rend()) {
                print_address(*it);
                it++;
            }
        }
        i++;
    }
}

// TODO: Super slow as it reconstructs the entire thing when mmapping a file
// TODO: Only add the new symbols
void update_symbols() {
    if (g_symbols_cached) {
        return;
    }

    auto lock = g_process_globals.symbols_lock.lock();
    g_process_globals.mapped_regions.clear();
    g_process_globals.symbols.clear();

    std::ifstream ifs("/proc/self/maps");
    std::string line;
    char buffer[PATH_MAX];
    std::map<std::string, std::pair<u64, u64>> regions{};
    while (std::getline(ifs, line)) {
        u64 start, end;
        int result = sscanf(line.c_str(), "%lx-%lx %*s %*s %*s %*s %s", &start, &end, buffer);
        if (result == 3) {
            if (!std::filesystem::is_regular_file(buffer)) {
                // Not a regular file, perhaps something like /dev/zero, so we don't add it
                VERBOSE("Buffer: %s is not regular file", buffer);
                continue;
            }

            auto it = regions.find(buffer);
            if (it == regions.end() && Elf::Peek(buffer) == Elf::PeekResult::NotElf) {
                VERBOSE("Buffer: %s is not an ELF", buffer);
                continue;
            }

            if (std::string(buffer).find(g_config.rootfs_path.string()) != 0) {
                // It's our emulator or its libraries, skip
                continue;
            }

            if (it == regions.end()) {
                VERBOSE("Adding new mapping: %s", buffer);
                regions[buffer] = {UINT64_MAX, 0};
            }

            std::pair<u64, u64>& region = regions[buffer];
            u64 new_start = std::min(region.first, start);
            u64 new_end = std::max(region.second, end);
            region.first = new_start;
            region.second = new_end;
            VERBOSE("Mapping %s extended: %lx-%lx", buffer, new_start, new_end);
        } else {
            // Failed to parse, is not a map line with a path, skip
            VERBOSE("While reading mappings, failed to parse line: %s", line.c_str());
        }
    }

    for (auto& region : regions) {
        std::string name = region.first;
        u64 start = region.second.first;
        u64 end = region.second.second;

        g_process_globals.mapped_regions[end - 1] = {.base = start, .end = end, .file = name};
        Elf::AddSymbols(g_process_globals.symbols, name, (u8*)start, (u8*)end);
    }

    g_symbols_cached = true;
}

std::string get_region(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto it = g_process_globals.mapped_regions.lower_bound(address);
    if (address >= it->second.base) {
        return it->second.file;
    } else {
        return "Unknown";
    }
}

bool has_region(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it == g_process_globals.mapped_regions.end()) {
        return false;
    }

    if (address >= region_it->second.base && address <= region_it->second.end) {
        return true;
    }

    return false;
}

std::string get_perf_symbol(u64 address) {
    auto lock = g_process_globals.symbols_lock.lock();
    auto symbol_it = g_process_globals.symbols.lower_bound(address);

    Symbol* symbol = nullptr;
    if (symbol_it != g_process_globals.symbols.end()) {
        u64 start = symbol_it->second.start;
        u64 end = symbol_it->second.start + symbol_it->second.size;
        if (address >= start && address <= end) {
            symbol = &symbol_it->second;
        }
    }

    bool file_found = false;
    std::string file = "??";
    u64 file_offset = address;
    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it != g_process_globals.mapped_regions.end()) {
        u64 start = region_it->second.base;
        u64 end = region_it->second.end;
        if (address >= start && address <= end) {
            file_found = true;
            file = std::filesystem::path(region_it->second.file).filename();

            if (file.size() > 20) {
                file = file.substr(0, 19);
                file += "...";
            }

            file_offset = address - region_it->second.base;
        }
    }

    const char* x86 = g_mode32 ? "x86" : "x86_64";
    std::string ret;
    if (symbol) {
        std::string symbol_name = symbol->name;
        if (symbol_name.size() > 30) {
            symbol_name = symbol_name.substr(0, 29);
            symbol_name += "...";
        }

        ret = fmt::format("{} {}@0x{:x} {}@0x{:x}", x86, file, file_offset, symbol->name, address - symbol->start);
    } else if (file_found) {
        ret = fmt::format("{} {}@0x{:x}", x86, file, file_offset);
    } else {
        ret = fmt::format("{} 0x{:x}", x86, address);
    }

    return ret;
}

void print_address(u64 address) {
    update_symbols();
    auto lock = g_process_globals.symbols_lock.lock();

    bool found = false;
    MappedRegion region{};

    auto region_it = g_process_globals.mapped_regions.lower_bound(address);
    if (region_it != g_process_globals.mapped_regions.end()) {
        u64 start = region_it->second.base;
        u64 end = region_it->second.end;
        if (address >= start && address <= end) {
            region = region_it->second;
            found = true;
        }
    }

    if (!found) {
        region.base = address;
        region.end = address;
        region.file = "??";
    }

    Symbol* symbol = nullptr;
    auto symbol_it = g_process_globals.symbols.lower_bound(address);
    if (symbol_it != g_process_globals.symbols.end()) {
        u64 start = symbol_it->second.start;
        u64 end = symbol_it->second.start + symbol_it->second.size;
        if (address >= start && address <= end) {
            symbol = &symbol_it->second;
        } else {
            VERBOSE("Lower bound doesn't match address: %lx - %lx %s, address is %lx", start, end, symbol_it->second.name.c_str(), address);
        }
    } else {
        VERBOSE("Lower bound not found for address: %lx", address);
    }

    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

    std::string filename = region.file;
    if (found) {
        filename = std::filesystem::path(region.file).filename();
    }

    const char* symbol_str = symbol ? symbol->name.c_str() : nullptr;
    std::string symbol_trunc;
    if (symbol_str) {
        symbol_trunc = symbol_str;
        if (symbol_trunc.size() > 40) {
            symbol_trunc = symbol_trunc.substr(0, 39);
            symbol_trunc += "...";
        }
    }

    // clang-format can't comprehend what I am about to do
    // clang-format off
    std::string filename_offset;
    if (filename == "??") {
        filename_offset = filename;
    } else {
        filename_offset = fmt::format("{}+0x{:x}", filename, address - region.base);
    }

    if (symbol_str) {
        u64 offset = address - symbol->start;
        Logger::log(
            ANSI_COLOR_CYAN "%s+0x%lx" ANSI_COLOR_RESET " in " ANSI_COLOR_YELLOW "%s" ANSI_COLOR_RESET " (0x%lx)\n",
            symbol_trunc.c_str(),
            offset,
            filename_offset.c_str(),
            address
        );
    } else {
        Logger::log(
            ANSI_COLOR_CYAN "0x%lx" ANSI_COLOR_RESET " in " ANSI_COLOR_YELLOW "%s" ANSI_COLOR_RESET "\n",
            address,
            filename_offset.c_str()
        );
    }
    // clang-format on
}

void push_calltrace(ThreadState* state, u64 address) {
    state->recompiler->getCalltrace().push_back(address);

    if (state->recompiler->getCalltrace().size() > 30) {
        state->recompiler->getCalltrace().pop_front();
    }

    if (g_print_all_calls) {
        dprintf(g_output_fd, "Thread %ld calling: ", state->tid);
        print_address(state->rip);
    }
}

void pop_calltrace(ThreadState* state) {
    if (state->recompiler->getCalltrace().empty()) {
        return;
    }

    if (g_print_all_calls) {
        dprintf(g_output_fd, "Thread %ld returning: ", state->tid);
        print_address(state->rip);
    }

    state->recompiler->getCalltrace().pop_back();
}

Float80 f64_to_80(double x) {
    union {
        double d;
        uint64_t u;
    } conv;
    conv.d = x;

    uint16_t sign = (conv.u >> 63) & 0x1;
    int16_t exponent = (conv.u >> 52) & 0x7FF;
    uint64_t significand = conv.u & 0xFFFFFFFFFFFFF;

    Float80 result;

    if (exponent == 0) {
        result.signExp = sign << 15;
        result.significand = significand;
    } else if (exponent == 0x7FF) {
        result.signExp = (sign << 15) | 0x7FFF;
        result.significand = significand ? (1ULL << 63) | significand : 0;
    } else {
        exponent = exponent - 1023 + 16383;
        significand |= (1ULL << 52);
        significand <<= 11;

        result.signExp = (sign << 15) | (exponent & 0x7FFF);
        result.significand = significand;
    }

    return result;
}

double f80_to_64(Float80* f80) {
    union {
        double d;
        uint64_t u;
    } conv;

    uint16_t sign = (f80->signExp >> 15) & 0x1;
    int16_t exponent = f80->signExp & 0x7FFF;
    uint64_t significand = f80->significand;

    if (exponent == 0) {
        conv.u = ((uint64_t)sign << 63) | (significand >> 11);
    } else if (exponent == 0x7FFF) {
        conv.u = ((uint64_t)sign << 63) | ((uint64_t)0x7FF << 52) | (significand ? (significand >> 11) : 0);
    } else {
        exponent = exponent - 16383 + 1023;
        significand >>= 11;

        conv.u = ((uint64_t)sign << 63) | ((uint64_t)exponent << 52) | (significand & 0xFFFFFFFFFFFFF);
    }

    return conv.d;
}

bool felix86_bt(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 value = __atomic_load_n(ptr, __ATOMIC_SEQ_CST);
    return (value >> bit_offset) & 1;
}

bool felix86_bts(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_or(ptr, 1 << bit_offset, __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

bool felix86_btr(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_and(ptr, ~(1 << bit_offset), __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

bool felix86_btc(u64 address, i64 offset) {
    u64 byte_offset = offset >> 3;
    u64 bit_offset = offset & 7;
    bool needs_correction = (offset < 0) && (bit_offset != 0);
    u8* ptr = (u8*)address + byte_offset - needs_correction;
    u8 old = __atomic_fetch_xor(ptr, 1 << bit_offset, __ATOMIC_SEQ_CST);
    return (old >> bit_offset) & 1;
}

const char* print_exit_reason(int reason) {
    switch (reason) {
    case EXIT_REASON_HLT:
        return "Hlt instruction";
    case EXIT_REASON_EXIT_SYSCALL:
        return "Exit syscall";
    case EXIT_REASON_EXIT_GROUP_SYSCALL:
        return "Exit group syscall";
    }

    return "Unknown";
}

void felix86_fsin(ThreadState* state) {
    double boop;
    memcpy(&boop, &state->fp[0], sizeof(double));
    double result = ::sin(boop);
    memcpy(&state->fp[0], &result, sizeof(double));
}

void felix86_fcos(ThreadState* state) {
    double boop;
    memcpy(&boop, &state->fp[0], sizeof(double));
    double result = ::cos(boop);
    memcpy(&state->fp[0], &result, sizeof(double));
}

void felix86_fpatan(ThreadState* state) {
    double st0, st1;
    memcpy(&st0, &state->fp[0], sizeof(double));
    memcpy(&st1, &state->fp[1], sizeof(double));
    double result = ::atan(st1 / st0);
    memcpy(&state->fp[1], &result, sizeof(double));
}

void felix86_f2xm1(ThreadState* state) {
    double boop;
    memcpy(&boop, &state->fp[0], sizeof(double));
    double result = ::exp2(boop) - 1.0;
    memcpy(&state->fp[0], &result, sizeof(double));
}

void felix86_fscale(ThreadState* state) {
    double st0, st1, result;
    memcpy(&st0, &state->fp[0], sizeof(double));
    if (st0 == 0) {
        result = 0.0;
    } else {
        memcpy(&st1, &state->fp[1], sizeof(double));
        result = st0 * ::exp2(trunc(st1));
    }
    memcpy(&state->fp[0], &result, sizeof(double));
}

void felix86_fyl2x(ThreadState* state) {
    double st0, st1;
    memcpy(&st0, &state->fp[0], sizeof(double));
    memcpy(&st1, &state->fp[1], sizeof(double));
    double result = st1 * log2(st0);
    memcpy(&state->fp[1], &result, sizeof(double));
}

void felix86_fyl2xp1(ThreadState* state) {
    double st0, st1;
    memcpy(&st0, &state->fp[0], sizeof(double));
    memcpy(&st1, &state->fp[1], sizeof(double));
    double result = st1 * log2(st0 + 1.0);
    memcpy(&state->fp[1], &result, sizeof(double));
}

template <class Int, int Count = 128 / (sizeof(Int) * 8), int UpperBound = Count - 1 /* 7 or 15 */, u32 Mask = (1u << Count) - 1u>
void pcmpxstrx_impl(ThreadState* state, pcmpxstrx type, Int* dst, Int* src, u8 control) {
    enum Mode {
        EqualAny = 0b00,
        Ranges = 0b01,
        EqualEach = 0b10,
        EqualOrdered = 0b11,
    };

    enum Polarity {
        Positive = 0b00,
        Negative = 0b01,
        MaskedPositive = 0b10,
        MaskedNegative = 0b11,
    };

    bool implicit = !(((u8)type >> 1) & 1);
    bool index = !(((u8)type) & 1);

    int dst_length;
    int src_length;

    Mode mode = (Mode)((control >> 2) & 0b11);
    Polarity polarity = (Polarity)((control >> 4) & 0b11);
    bool output_selection = (control >> 6) & 1;

    std::array<bool, Count * Count> BoolRes{};
    if (implicit) {
        dst_length = Count;
        src_length = Count;

        bool dst_length_found = false;
        bool src_length_found = false;

        for (int i = 0; i < Count; i++) {
            if (!dst_length_found && dst[i] == 0) {
                dst_length = i;
                dst_length_found = true;
            }

            if (!src_length_found && src[i] == 0) {
                src_length = i;
                src_length_found = true;
            }

            if (dst_length_found && src_length_found) {
                break;
            }
        }
    } else {
        dst_length = (int)state->gprs[0]; // eax
        src_length = (int)state->gprs[2]; // edx

        ASSERT(dst_length >= 0);
        ASSERT(src_length >= 0);
    }

    for (int j = 0; j < Count; j++) {
        for (int i = 0; i < Count; i++) {
            if (mode == Ranges) {
                if (i % 2 == 0) {
                    BoolRes[j * Count + i] = src[j] >= dst[i];
                } else {
                    BoolRes[j * Count + i] = src[j] <= dst[i];
                }
            } else {
                BoolRes[j * Count + i] = dst[i] == src[j];
            }
        }
    }

    auto dst_invalid = [&](int index) { return index >= dst_length; };
    auto src_invalid = [&](int index) { return index >= src_length; };

    auto overrideIfInvalid = [&](u64 dst_index, u64 src_index) {
        bool dstinv = dst_invalid(dst_index);
        bool srcinv = src_invalid(src_index);

        switch (mode) {
        case Ranges:
        case EqualAny: {
            if (!dstinv && !srcinv) {
                return BoolRes[src_index * Count + dst_index];
            }
            return false;
        }
        case EqualEach: {
            if (!dstinv && !srcinv) {
                return BoolRes[src_index * Count + dst_index];
            }

            if (dstinv && srcinv) {
                return true;
            }

            return false;
        }
        case EqualOrdered: {
            if (!dstinv && !srcinv) {
                return BoolRes[src_index * Count + dst_index];
            }

            if ((dstinv && srcinv) || (dstinv && !srcinv)) {
                return true;
            }

            return false;
        }
        }

        __builtin_unreachable();
    };

    u32 intres1 = 0;
    switch (mode) {
    case EqualAny: {
        for (int j = 0; j <= UpperBound; j++) {
            for (int i = 0; i <= UpperBound; i++) {
                u32 bit = overrideIfInvalid(i, j);
                intres1 |= bit << j;
            }
        }
        break;
    }
    case Ranges: {
        for (int j = 0; j <= UpperBound; j++) {
            for (int i = 0; i <= UpperBound; i += 2) {
                u32 bit1 = overrideIfInvalid(i, j);
                u32 bit2 = overrideIfInvalid(i + 1, j);
                intres1 |= (bit1 & bit2) << j;
            }
        }
        break;
    }
    case EqualEach: {
        for (int i = 0; i <= UpperBound; i++) {
            u32 bit = overrideIfInvalid(i, i);
            intres1 |= bit << i;
        }
        break;
    }
    case EqualOrdered: {
        intres1 = 0;
        for (int j = 0; j < src_length; j++) {
            bool match = true;
            for (int i = 0; i < dst_length && (j + i) < src_length; i++) {
                if (!overrideIfInvalid(i, j + i)) {
                    match = false;
                    break;
                }
            }
            if (match) {
                intres1 |= (1 << j);
            }
        }
        break;
    }
    }

    u32 intres2 = intres1;
    switch (polarity) {
    case Negative: {
        intres2 = -1 ^ intres1;
        break;
    }
    case MaskedNegative: {
        intres2 = 0;
        for (int i = 0; i <= UpperBound; i++) {
            u32 old_bit = (intres1 >> i) & 1;
            u32 bit = src_invalid(i) ? old_bit : (old_bit ^ 1);
            intres2 |= bit << i;
        }
        break;
    }
    default: {
        break;
    }
    }
    intres2 &= Mask;

    if (index) {
        // pcmpxstri instructions
        static_assert(X86_REF_RCX == 1);
        if (intres2 == 0) {
            state->gprs[1] = Count;
        } else {
            if (!output_selection) {
                state->gprs[1] = __builtin_ctz(intres2);
            } else {
                u32 shifted = intres2 << (32 - Count);
                state->gprs[1] = (Count - 1) - __builtin_clz(shifted);
            }
        }
    } else {
        // pcmpxstrm instructions
        if (!output_selection) {
            for (u32 i = 0; i < (sizeof(XmmReg) / sizeof(u64)); i++) {
                state->xmm[0].data[i] = 0;
            }

            state->xmm[0].data[0] = intres2;
        } else {
            static_assert(Count == 8 || Count == 16);
            if (Count == 16) {
                u8* xmm0 = (u8*)&state->xmm[0].data[0];
                for (int i = 0; i < 16; i++) {
                    u32 bit = (intres2 >> i) & 1;
                    if (bit) {
                        xmm0[i] = 0xFF;
                    } else {
                        xmm0[i] = 0;
                    }
                }
            } else {
                u16* xmm0 = (u16*)&state->xmm[0].data[0];
                for (int i = 0; i < 8; i++) {
                    u32 bit = (intres2 >> i) & 1;
                    if (bit) {
                        xmm0[i] = 0xFFFF;
                    } else {
                        xmm0[i] = 0;
                    }
                }
            }
        }
    }

    state->cf = intres2 != 0;
    // Works for both implicit and explicit variants
    state->zf = src_length < Count;
    state->sf = dst_length < Count;
    state->of = intres2 & 1;
    state->af = 0;
    state->pf = 0;
}

void felix86_pcmpxstrx(ThreadState* state, pcmpxstrx type, u8* dst, u8* src, u8 control) {
    enum Type {
        UnsignedBytes = 0b00,
        UnsignedWords = 0b01,
        SignedBytes = 0b10,
        SignedWords = 0b11,
    };

    switch ((Type)(control & 0b11)) {
    case UnsignedBytes: {
        return pcmpxstrx_impl<u8>(state, type, (u8*)dst, (u8*)src, control);
    }
    case UnsignedWords: {
        return pcmpxstrx_impl<u16>(state, type, (u16*)dst, (u16*)src, control);
    }
    case SignedBytes: {
        return pcmpxstrx_impl<i8>(state, type, (i8*)dst, (i8*)src, control);
    }
    case SignedWords: {
        return pcmpxstrx_impl<i16>(state, type, (i16*)dst, (i16*)src, control);
    }
    }

    __builtin_unreachable();
}

u64 mmap_min_addr() {
    static u64 addr = []() {
        FILE* file = fopen("/proc/sys/vm/mmap_min_addr", "r");
        u64 ret;
        if (!file) {
            WARN("Failed to open /proc/sys/vm/mmap_min_addr");
            ret = 0x10000;
        } else {
            u64 mmap_min_addr;
            if (fscanf(file, "%lu", &mmap_min_addr) != 1) {
                WARN("Failed to read mmap_min_addr");
                ret = 0x10000;
            } else {
                ret = mmap_min_addr;
            }
            fclose(file);
        }
        return ret;
    }();

    return addr;
}

void felix86_set_segment(ThreadState* state, u64 value, ZydisRegister segment) {
    int index = value >> 3;
    u32 base = state->gdt[index];

    switch (segment) {
    case ZYDIS_REGISTER_CS: {
        state->cs = value;
        state->csbase = base;
        break;
    }
    case ZYDIS_REGISTER_DS: {
        state->ds = value;
        state->dsbase = base;
        break;
    }
    case ZYDIS_REGISTER_SS: {
        state->ss = value;
        state->ssbase = base;
        break;
    }
    case ZYDIS_REGISTER_ES: {
        state->es = value;
        state->esbase = base;
        break;
    }
    case ZYDIS_REGISTER_FS: {
        state->fs = value;
        state->fsbase = base;
        break;
    }
    case ZYDIS_REGISTER_GS: {
        state->gs = value;
        state->gsbase = base;
        break;
    }
    default: {
        UNREACHABLE();
        break;
    }
    }
}

void felix86_fprem(ThreadState* state) {
    const u64 st0 = state->fp[0];
    const u64 st1 = state->fp[1];
    double st0d, st1d;
    memcpy(&st0d, &st0, 8);
    memcpy(&st1d, &st1, 8);
    const int exp0 = (st0 >> 52) & 0x7FF;
    const int exp1 = (st1 >> 52) & 0x7FF;
    const int D = exp0 - exp1;
    if (D < 64) {
        const i64 Q = (i64)(trunc(st0d / st1d));
        st0d -= st1d * Q;
        state->fpu_sw &= ~(C0_BIT | C1_BIT | C2_BIT | C3_BIT);
        state->fpu_sw |= (Q & 1) ? C1_BIT : 0;
        state->fpu_sw |= (Q & 2) ? C3_BIT : 0;
        state->fpu_sw |= (Q & 4) ? C0_BIT : 0;
    } else {
        const double p2 = exp2(D - 32);
        const i64 Q = trunc((st0d / st1d) / p2);
        st0d -= st1d * Q * p2;
        state->fpu_sw |= C2_BIT;
    }

    // Writeback the new ST(0) value
    memcpy(&state->fp[0], &st0d, 8);
}

void felix86_fxam(ThreadState* state) {
    u64 st0 = state->fp[0];
    bool sign = st0 >> 63;
    double st0d;
    memcpy(&st0d, &st0, 8);

    u8 c3c2c0;
    if (st0d == 0.0) {
        c3c2c0 = 0b100;
    } else if (std::isinf(st0d)) {
        c3c2c0 = 0b011;
    } else {
        c3c2c0 = 0b010;
    }

    bool c0 = c3c2c0 & 1;
    bool c1 = sign;
    bool c2 = (c3c2c0 >> 1) & 1;
    bool c3 = (c3c2c0 >> 2) & 1;

    state->fpu_sw &= ~(C0_BIT | C1_BIT | C2_BIT | C3_BIT);
    state->fpu_sw |= c0 ? C0_BIT : 0;
    state->fpu_sw |= c1 ? C1_BIT : 0;
    state->fpu_sw |= c2 ? C2_BIT : 0;
    state->fpu_sw |= c3 ? C3_BIT : 0;
}

const std::string& felix86_cpuinfo() {
#define ADD_FLAG(cond, name)                                                                                                                         \
    do {                                                                                                                                             \
        if (cond) {                                                                                                                                  \
            flags += name;                                                                                                                           \
            flags += " ";                                                                                                                            \
        }                                                                                                                                            \
    } while (0)

    static std::string cpuinfo = []() {
        std::string result;
        std::string flags;
        Cpuid cpuid_0 = felix86_cpuid_impl(0, 0);
        Cpuid cpuid_1 = felix86_cpuid_impl(1, 0);
        Cpuid cpuid_7 = felix86_cpuid_impl(7, 0);

        ADD_FLAG(cpuid_1.edx & (1 << 0), "fpu");
        ADD_FLAG(cpuid_1.edx & (1 << 1), "vme");
        ADD_FLAG(cpuid_1.edx & (1 << 2), "de");
        ADD_FLAG(cpuid_1.edx & (1 << 3), "pse");
        ADD_FLAG(cpuid_1.edx & (1 << 4), "tsc");
        ADD_FLAG(cpuid_1.edx & (1 << 5), "msr");
        ADD_FLAG(cpuid_1.edx & (1 << 6), "pae");
        ADD_FLAG(cpuid_1.edx & (1 << 7), "mce");
        ADD_FLAG(cpuid_1.edx & (1 << 8), "cx8");
        ADD_FLAG(cpuid_1.edx & (1 << 9), "apic");
        ADD_FLAG(cpuid_1.edx & (1 << 11), "sep");
        ADD_FLAG(cpuid_1.edx & (1 << 12), "mtrr");
        ADD_FLAG(cpuid_1.edx & (1 << 13), "pge");
        ADD_FLAG(cpuid_1.edx & (1 << 14), "mca");
        ADD_FLAG(cpuid_1.edx & (1 << 15), "cmov");
        ADD_FLAG(cpuid_1.edx & (1 << 16), "pat");
        ADD_FLAG(cpuid_1.edx & (1 << 17), "pse36");
        ADD_FLAG(cpuid_1.edx & (1 << 18), "pn");
        ADD_FLAG(cpuid_1.edx & (1 << 19), "clflush");
        ADD_FLAG(cpuid_1.edx & (1 << 21), "ds");
        ADD_FLAG(cpuid_1.edx & (1 << 22), "acpi");
        ADD_FLAG(cpuid_1.edx & (1 << 23), "mmx");
        ADD_FLAG(cpuid_1.edx & (1 << 24), "fxsr");
        ADD_FLAG(cpuid_1.edx & (1 << 25), "sse");
        ADD_FLAG(cpuid_1.edx & (1 << 26), "sse2");
        ADD_FLAG(cpuid_1.edx & (1 << 27), "ss");
        ADD_FLAG(cpuid_1.edx & (1 << 28), "ht");
        ADD_FLAG(cpuid_1.edx & (1 << 29), "tm");
        ADD_FLAG(cpuid_1.edx & (1 << 30), "ia64");
        ADD_FLAG(cpuid_1.edx & (1 << 31), "pbe");
        ADD_FLAG(cpuid_1.ecx & (1 << 0), "pni");
        ADD_FLAG(cpuid_1.ecx & (1 << 1), "pclmulqdq");
        ADD_FLAG(cpuid_1.ecx & (1 << 2), "dtes64");
        ADD_FLAG(cpuid_1.ecx & (1 << 3), "monitor");
        ADD_FLAG(cpuid_1.ecx & (1 << 4), "ds_cpl");
        ADD_FLAG(cpuid_1.ecx & (1 << 5), "vmx");
        ADD_FLAG(cpuid_1.ecx & (1 << 6), "smx");
        ADD_FLAG(cpuid_1.ecx & (1 << 7), "est");
        ADD_FLAG(cpuid_1.ecx & (1 << 8), "tm2");
        ADD_FLAG(cpuid_1.ecx & (1 << 9), "ssse3");
        ADD_FLAG(cpuid_1.ecx & (1 << 11), "sdbg");
        ADD_FLAG(cpuid_1.ecx & (1 << 12), "fma");
        ADD_FLAG(cpuid_1.ecx & (1 << 13), "cx16");
        ADD_FLAG(cpuid_1.ecx & (1 << 14), "xptr");
        ADD_FLAG(cpuid_1.ecx & (1 << 15), "pdcm");
        ADD_FLAG(cpuid_1.ecx & (1 << 17), "pcid");
        ADD_FLAG(cpuid_1.ecx & (1 << 18), "dca");
        ADD_FLAG(cpuid_1.ecx & (1 << 19), "sse4_1");
        ADD_FLAG(cpuid_1.ecx & (1 << 20), "sse4_2");
        ADD_FLAG(cpuid_1.ecx & (1 << 21), "x2apic");
        ADD_FLAG(cpuid_1.ecx & (1 << 22), "movbe");
        ADD_FLAG(cpuid_1.ecx & (1 << 23), "popcnt");
        ADD_FLAG(cpuid_1.ecx & (1 << 24), "tsc_deadline_timer");
        ADD_FLAG(cpuid_1.ecx & (1 << 25), "aes");
        ADD_FLAG(cpuid_1.ecx & (1 << 26), "xsave");
        ADD_FLAG(cpuid_1.ecx & (1 << 28), "avx");
        ADD_FLAG(cpuid_1.ecx & (1 << 29), "f16c");
        ADD_FLAG(cpuid_1.ecx & (1 << 30), "rdrand");
        ADD_FLAG(cpuid_1.ecx & (1 << 31), "hypervisor");

        ADD_FLAG(cpuid_7.ebx & (1 << 0), "fsgsbase");
        ADD_FLAG(cpuid_7.ebx & (1 << 1), "tsc_adjust");
        ADD_FLAG(cpuid_7.ebx & (1 << 3), "bmi1");
        ADD_FLAG(cpuid_7.ebx & (1 << 4), "hle");
        ADD_FLAG(cpuid_7.ebx & (1 << 5), "avx2");
        ADD_FLAG(cpuid_7.ebx & (1 << 7), "smep");
        ADD_FLAG(cpuid_7.ebx & (1 << 8), "bmi2");
        ADD_FLAG(cpuid_7.ebx & (1 << 9), "erms");
        ADD_FLAG(cpuid_7.ebx & (1 << 10), "invpcid");
        ADD_FLAG(cpuid_7.ebx & (1 << 11), "rtm");
        ADD_FLAG(cpuid_7.ebx & (1 << 12), "rdt_m");
        ADD_FLAG(cpuid_7.ebx & (1 << 13), "depc_fpu_cs_ds");
        ADD_FLAG(cpuid_7.ebx & (1 << 14), "mpx");
        ADD_FLAG(cpuid_7.ebx & (1 << 15), "rdt_a");
        ADD_FLAG(cpuid_7.ebx & (1 << 16), "avx512f");
        ADD_FLAG(cpuid_7.ebx & (1 << 17), "avx512dq");
        ADD_FLAG(cpuid_7.ebx & (1 << 18), "rdseed");
        ADD_FLAG(cpuid_7.ebx & (1 << 19), "adx");
        ADD_FLAG(cpuid_7.ebx & (1 << 20), "smap");
        ADD_FLAG(cpuid_7.ebx & (1 << 21), "avx512ifma");
        ADD_FLAG(cpuid_7.ebx & (1 << 23), "clflushopt");
        ADD_FLAG(cpuid_7.ebx & (1 << 24), "clwb");
        ADD_FLAG(cpuid_7.ebx & (1 << 25), "intel_pt");
        ADD_FLAG(cpuid_7.ebx & (1 << 26), "avx512pf");
        ADD_FLAG(cpuid_7.ebx & (1 << 27), "avx512er");
        ADD_FLAG(cpuid_7.ebx & (1 << 28), "avx512cd");
        ADD_FLAG(cpuid_7.ebx & (1 << 29), "sha_ni");
        ADD_FLAG(cpuid_7.ebx & (1 << 30), "avx512bw");
        ADD_FLAG(cpuid_7.ebx & (1 << 31), "avx512vl");

        flags.pop_back();

        u32 family_id = (cpuid_1.eax >> 8) & 0xF;
        u32 ex_family_id = (cpuid_1.eax >> 20) & 0xFF;
        u32 ex_model = ((cpuid_1.eax >> 16) & 0xF) << 4;
        bool family_6_or_15 = family_id == 6 || family_id == 15;
        u32 model = ((cpuid_1.eax >> 4) & 0xF) | (family_6_or_15 ? ex_model : 0);
        u32 family = family_id + (family_id == 0xF ? ex_family_id : 0);

        cpu_set_t cpuset;
        sched_getaffinity(0, sizeof(cpuset), &cpuset);
        int core_count = CPU_COUNT(&cpuset);
        for (int i = 0; i < core_count; i++) {
            result += fmt::format("processor\t: {}\n", i);
            result += "vendor_id\t: GenuineIntel\n";
            result += fmt::format("cpu family\t: {}\n", family);
            result += fmt::format("model\t\t: {}\n", model);
            result += "model name\t: felix86\n"; // TODO: get it from CPUID
            result += fmt::format("stepping\t: {}\n", cpuid_1.eax & 0xF);
            result += "microcode\t: 0x42c\n";
            result += "cpu MHz\t\t: 1000.0\n";  // TODO: calculate it
            result += "cache size\t: 512 KB\n"; // TODO: get from /sys/devices/system/cpu/cpu%d/cache/index%d/size (if no L3, use L2)
            result += "physical id\t: 0\n";
            result += fmt::format("siblings\t: {}\n", core_count);
            result += fmt::format("core id\t\t: {}\n", i);
            result += fmt::format("cpu cores\t: {}\n", core_count);
            result += fmt::format("apicid\t\t: {}\n", i);
            result += fmt::format("initial apicid\t: {}\n", i);
            result += "fpu\t\t: 1\n";
            result += "fpu exception\t: 1\n";
            result += fmt::format("cpuid level\t: {}\n", cpuid_0.eax);
            result += "wp\t\t: yes\n";
            result += fmt::format("flags\t\t: {}\n", flags);
            result += "bugs\t\t: \n";
            result += "bogomips\t: 5000.0\n"; // TODO: also calculate this
            result += "clflush size\t: 64\n";
            result += "cache_alignment\t: 64\n";
            result += "address sizes\t: 56 bits physical, 39 bits virtual\n"; // TODO: get virtual from mmu in /proc/cpuinfo
            result += "power management:\n";
            result += "\n";
        }

        return result;
    }();
    return cpuinfo;
#undef ADD_FLAG
}